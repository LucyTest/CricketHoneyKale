{"name":"Cricket  Honey Kale","tagline":"Nutritional Recipe Generator Final Project","body":"# Final Project Proposal: Lisa Hachmann, Logan Sweet, Lucy Wilcox (Section 2)\r\n\r\n\r\n\r\nThe Big Idea\r\n\r\nWe are creating a software which will generate recipes for most daily food types, with a focus on cooking not baking. We are exploring data management, computer generated information, and GUIs. Our minimum viable product is generating a passable salad recipe. Additional goals are creating really tasty recipes, beautiful UI/UX, giving the program increasing levels of freedom and having it still render good food, and the user might also be able to give feedback and possibly even learn from said feedback.\r\n\r\nLearning Goals\r\n\r\nAll three of us are interested in learning how to make and use GUIs. Lucy is interested in deciding how the computer will generate and decide the recipes, Lisa is interested in how it will use and manipulate the information from the database, and Logan wants to focus the most on creating the GUI. We want to get more familiar with classes, plan our code structure before we begin implementing, become more comfortable using Git, and have clean, reliable, readable, commented code.\r\n\r\nImplementation Plan\r\n\r\nWe will start with recipe data manipulation in order to move into recipe generation. We will chose a GUI library with the insight of others (professors, NINJAs). We will address our recipe as a dictionary or list of ingredients, and also perhaps with some sort of taste profile. Overall, the program would look at other recipes and see what foods appear together and then look at this online data to chose food combinations. \r\n\r\nProject schedule\r\n\r\nDeadlines:\r\n\r\nMarch 30: Create basic implementation plan for software, Have recipe database for testing\r\n\r\nApril 2: Design Review!\r\n\r\n\tDeliverable: If you have one ingredient, give 1-5 ingredients that go with it. Have final design plan for software execution. \r\n\r\nApril 6: Use generated list of recipes to make instructions\r\n\r\nApril 13: Code Review!\r\n\r\nApril 20: Continue to refine instructions\r\n\r\nApril 23: Mid-Project presentation, Think about GUI\r\n\r\nApril 27: Determine if a recipe is “good” or not\r\n\r\nMay 4: Finish project; practice final presentation\r\n\r\nMay 6: Final due date and project presentation\r\n\r\nCollaboration plan\r\n\r\nWe plan to have multiple pair programming techniques: rotating pair programming and experiment with triple programming (having a driver, navigator, and googler). We plan on having quick reflections with every deadline but also decide before every meeting what we will try to get done, and after every meeting decide what we should individually do before the next meeting. Logan and Lisa both prefer working in pairs, while Lucy is flexible and neutral, so the decisions on the pairing of work will happen based more on scheduling. We will also have multiple files (one for the GUI and one or more for dealing with our data) so people can focus on different parts and work at the same time. Floobits might also be used so we can work together on the code.\r\n \r\nRisks\r\n\r\nWe are at risk for making nasty recipes and having inaccurate instructions. The instructions will be a particularly large risk just because every recipe cooks differently and it’s hard to base the instructions of a new recipe off an old one. To avoid this, we will start with salads and smoothies, examples of foods with a standard instruction pattern. Getting a functional GUI will be more difficult than running our software through the terminal, but will make a huge difference in terms of professionalism and functionality. \r\n\r\nAdditional Course Content\r\n\r\nSupport on other GUI platforms besides PyGame would be useful to learn about in class. The rest of the project seems manageable with the course content we have already learned, although more understanding of classes and objects will of course help us. We  don’t really know what machine learning is, but it might be useful. \r\n\r\n______________________________________________________\r\n\r\n# Framing Document: \r\n\r\nCricket Honey Kale: Lucy Wilcox, Lisa Hachmann, Logan Sweet \r\nDesign Review\r\n\r\n\r\n\r\nBackground and context: \r\n\r\nWe are making a program that generates recipes by using web mined data from recipes online. Our recipe will both have ingredients and instructions. We are focusing on cooking, not baking (no yeast, baking powder, or baking soda). We may only complete a simpler version of this which creates salad or smoothie recipes. Our audience should know something about food (which we really hope/assume they do) and that’s about it!\r\n\r\nKey questions:\r\n\r\nOur questions are as follows: \r\n\r\nHow should the recipe URLs and recipes be stored? \r\n\r\nWhat GUI is simple to implement and can fit our needs?\r\n\r\nWhat logic should we use to use to generate recipes? \r\n\r\n    looking at what ingredients are often used together?\r\n\r\n    create flavor profiles and pull from those lists?\r\n\r\n    other? \r\n\r\nDo you know of any libraries that would be useful to us?\r\n\r\nWe are most interested in hearing others’ ideas on how we could generate recipes. Since part of our goal in creating recipes is to create good recipes, we know that our ingredient selection algorithm will be essential. While we have a couple ideas as to how the logic of this part of our software will work, we would like some feedback as to whether or not people think our plan will be successful as well as hearing any other ideas for the logic of recipe selection.  \r\n\r\nAgenda for technical review session:\r\n\r\nWe are planning to use the collaborative ideation structure for our design review. We will pass out post it notes in the beginning of class and present questions while we explain the steps of our project and the questions we have about each step. At the end of the presentation we will have an ideation period for all of the questions said during the presentation. At the end of the ideation period, we will have the audience put the questions on the whiteboards and ask all of the solutions to be put under the allotted whiteboard space for that question. A discussion can be started if necessary to explain certain solutions where everyone can weigh in with pros and cons regarding each.\r\n_____________________________________________________\r\nSoftware Design Review 1- Reflections\r\n\r\nby Cricket Honey Kale\r\n\r\nFeedback and Decisions\r\n\r\nWe were told that we'd be able to make more recipes than we had originally planned by starting with classes that have one repeatable/slightly adjustable instruction set. As well, we were told about qtpython, flask and django as gui options. As for the recipe generation methodology, the consensus of the group validated our idea of how to sort and combine ingredients. There were additional edge cases that were pointed out, like not to randomly select more than one heating process (cooking, frying, boiling) and, for example, not frying, baking and then boiling a chicken. In order to implement it, we will put in code to protect from the edge cases, look at the guis presented and try one library each to select the best one, and each choose one class of food category to create, after the general shifting of our current classes. The new questions that came up for us is how exactly we’d like the user interface to look and how many categories of food we will have to time to incorporate. \r\n\r\nReview Process Reflection: \r\n\r\nSince we forced ideation by getting people up to whiteboards, it seemed that we received a greater quantity of feedback than other groups in our section. Since people were interacting with each other while ideating, they were able to generate ideas in a more team oriented way. The main question, that of which GUI we should use, was not fully nailed down, but we received good advice which we will continue to take under consideration. We think that by offering little more than questions for people when we asked for feedback that we allowed for a greater amount of freedom in people’s thoughts, which hopefully let to more creativity. We could have made this process better by not mentioning some of the answers we were considering to not constrain people to one line of thinking, especially in terms of our thought process for ingredient list creation. Our planned agenda was very loose and allowed for a lot of discussion between participants in the design review as well as between us and the reviewers. This setup worked well for us, and we will consider repeating this strategy in future design reviews. \r\n\r\n________________________________________________________\r\n#Code Review:\r\nCricket Honey Kale\r\nBackground and context:\r\nTo generate recipes we have one class which contains data from online recipes, most importantly an ingredient list. We will mostly reference our salad code in the review, but we have other similarly working codes like soup and smoothies. Then, in another file, a starting ingredient is randomly selected and the salad (we will mostly reference our salad code in the review, but we have other similarly working codes with soup and smoothies) starts with an attribute which contains all instances of the recipe class. Then the instances of the recipe class which do not contain the ingredients are deleted from the attribute. At this point the remaining recipes all have the current ingredients which are current toppings. The ingredient list attribute from the recipes classes that have not been removed are appended to an attribute on salads (which is a list of these ingredient strings). Then each of these ingredient strings is looped through and compared to a list of salad toppings, if a salad topping is present the salad topping is appended to a list which the next ingredient is randomly chosen from. \r\n\r\nWe have a few other features we don’t plan on focusing on during this review, which are the start of a GUI, and a program which determines the correct preparation method of the ingredient (for example: should the scallions be chopped or pureed) by using parts of speech. We also have a class for smoothies and soups.\r\n\r\nKey questions\r\nHow many recipes do you think we have to reference in order to have good validation? \r\nHow can we introduce a “risk factor”? (A way to incorporate unpredictable ingredients)\r\nHow do we create instructions that make sense?\r\n\r\nAgenda for technical review session\r\nBe specific about how you plan to use your allotted time. What strategies will you use to communicate with your audience?\r\n\r\nWe will first give an overview of where we are and what our code does/code structure. We will then present our present issues and pose questions on them which the audience will be asked to keep in mind going forward. Lastly we will display our code on the projector and have a technical discussion on each issue that we had previously stated. We hope to the audiences’ fresh eyes will help us come up with ways to produce our recipes more quickly.\r\n___________________________________________________________-\r\n#Code Review Reflection:\r\nFeedback and decisions:\r\nIn order to generate instructions for each recipe we will begin with a fill-in method similar to madlibs and hopefully progress to a more tailored approach as we can better evaluate how each ingredient is used. People seemed very receptive to the idea of a risk factor in recipes, so we would like to incorporate it into our final product. To do this, we might use degrees of separation (how many recipes you have jump through before you get another recipe that has the next ingredient) to determine how reasonable or unreasonable an ingredient is. We also will look into the Yumly API since it has a built-in flavor profile ranking system, but will likely stick with our current implementation. \r\n\r\nReview process reflection: \r\n(Un)Fortunately, we solved our greatest problem that we intended to present during the code review the night before at around 11 pm. Because of this lack of significant coding problem, we had to scramble to find a big problem we could present to the group to get feedback on. Finding none, we choose a few questions that were significant to our project, but were not necessarily problems but rather design decisions. These three questions, that 1. asked what a reasonable number of recipes was necessary to generate a good variety of recipes, 2. asked how to generate instructions for each recipe that made sense, and 3. asked if people would be interested in a “danger factor” in their generated recipes turned our code review into a design review on accident. If the timing of the code review had been different we would have likely completed it as a true code review, but without a significant problem we felt no need to put our code in front of the class: without a more developed understanding of how our code works we did not think it would likely be very helpful for us or enjoyable for them. We still probably should have run the code we have now so that people would have quickly understood where we are.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}